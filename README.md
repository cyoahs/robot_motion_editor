# 机器人关键帧编辑器

一个基于 Web 的机器人关键帧编辑工具，支持 URDF 文件加载、CSV 轨迹编辑和双视口 3D 可视化对比。

## 🌐 在线体验

**Live Demo**: [motion-editor.cyoahs.dev](https://motion-editor.cyoahs.dev)

*托管在 Cloudflare Pages 上*

## 🔒 隐私安全

> **✅ 完全本地运行**  
> 本工具所有数据处理均在您的浏览器本地完成，不会上传任何文件或数据到服务器。  
> 如有顾虑，您可以选择本地部署使用（见下方安装说明）。

## ✨ 核心特性

### 🎬 双视口对比显示
- **左侧视口**: 显示原始 CSV 轨迹（Base）
- **右侧视口**: 显示叠加关键帧后的编辑结果（Modified）
- **相机同步**: 操作一侧相机，另一侧自动跟随
- **实时对比**: 直观查看原始轨迹和编辑后的效果差异

### 📐 基体控制
- **位置调整**: 修正机器人基座的 xyz 坐标
- **姿态调整**: 编辑四元数 (xyzw)，自动归一化
- **折叠式 UI**: 默认折叠，节省空间
- **残差系统**: 修改会作为残差叠加到原始轨迹上

### 🦾 关节控制
- 每个关节独立控制（滑块 + 数字输入）
- 自动关键帧更新（在关键帧上修改时）
- 重置按钮（恢复到 base 值）
- 紧凑式横向布局

### ⏱️ 时间轴控制
- 拖动浏览任意时刻
- 播放/暂停功能（可配置 FPS）
- 关键帧标记显示
- 右键删除关键帧

## 功能特性

- **URDF 加载**: 支持加载整个文件夹，自动解析 URDF 文件中的相对路径引用的 mesh 文件
- **CSV 轨迹加载**: 加载轨迹数据（前 7 列为 base 的 xyz + 四元数 xyzw，后面为关节位置）
- **3D 可视化**: 使用 Three.js 实时渲染机器人模型（Z-up 坐标系）
- **关键帧编辑**: 基于残差的关键帧系统，CSV 为基础轨迹，编辑的关键帧为残差
- **轨迹导出**: 导出叠加后的完整轨迹，智能文件名（原名_modified.csv）

## 技术栈

- **Vite**: 现代化的前端构建工具
- **Three.js**: 3D 图形渲染库
- **urdf-loader**: URDF 文件解析库
- **原生 JavaScript**: 无框架依赖，轻量高效

## 安装与运行

```bash
# 安装依赖
npm install

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build

# 预览生产构建
npm run preview
```

## 使用说明

### 1. 加载 URDF 文件夹

点击 "加载 URDF 文件夹" 按钮，选择包含 URDF 文件及其引用的 mesh 文件的完整文件夹。工具会自动：
- 查找 `.urdf` 文件
- 解析相对路径引用
- 加载所有 mesh 文件
- 在 3D 视图中渲染机器人模型

### 2. 加载 CSV 轨迹

点击 "加载 CSV 轨迹" 按钮，选择轨迹 CSV 文件。

**文件格式要求**：
- 每行代表一帧
- 前 7 列: `x, y, z, qx, qy, qz, qw` (base 位置和四元数)
- 后续列: 关节位置（弧度制）
- 加载时会提示设置 FPS（默认 50）

示例：
```csv
0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, -1.0, 1.5, ...
0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 1.0, 0.1, 0.6, -1.1, 1.6, ...
```

**注意事项**：
- 加载新 CSV 时会清除所有现有关键帧
- 系统会记住原始文件名用于导出时命名

### 3. 双视口对比

- **左侧视口**: 始终显示原始 CSV 轨迹
- **右侧视口**: 显示编辑后的轨迹（base + 关键帧残差）
- **同步相机**: 操作任一视口的相机，另一侧会自动跟随
- **实时对比**: 可直观看到编辑前后的差异

### 4. 基体控制（可选）

点击 "▶ 基体控制 (Base)" 展开：
- **Position (xyz)**: 调整机器人基座的位置（单位：米）
- **Quaternion (xyzw)**: 调整基座姿态，每次调整后自动归一化
- 在关键帧上修改时会自动更新基体残差

### 5. 关节编辑

- 右侧面板显示所有可动关节
- 每个关节有滑块和数字输入框
- 修改关节值会实时更新右侧视口的机器人姿态
- 在关键帧上修改时会自动更新残差

### 6. 添加关键帧

1. 在时间轴上选择要添加关键帧的时刻
2. 在右侧调整关节和/或基体到期望的姿态
3. 点击 "添加关键帧" 按钮
4. 系统会计算当前值与 base 值的残差并保存
   - 关节残差 = 当前关节值 - base 关节值
   - 基体残差 = 当前基体值 - base 基体值
5. 关键帧会在时间轴上以绿色标记显示

**自动更新**：
- 如果在已有关键帧上修改关节或基体，残差会自动更新
- 无需重新点击"添加关键帧"按钮

### 7. 播放控制

- **播放/暂停**: 点击按钮播放或暂停动画
- **FPS 配置**: 在加载 CSV 时设置，默认 50 FPS
- **实时更新**: 播放时两个视口会同步更新

### 8. 删除关键帧

方法一：点击删除按钮
- 将时间轴移动到要删除的关键帧位置
- 点击 "删除当前关键帧" 按钮

方法二：右键点击标记
- 在时间轴上右键点击关键帧标记
- 在弹出的确认对话框中选择确定

### 9. 导出轨迹

点击 "导出轨迹" 按钮：
1. 系统会对所有关键帧进行线性插值
2. 将关节和基体残差叠加到 base 轨迹上
3. 弹出文件名输入框，默认为 `原文件名_modified.csv`
4. 确认后下载 CSV 文件（格式与输入相同）

**导出格式**：
- 与输入格式完全相同
- 前 7 列为叠加后的 base 位置和姿态
- 后续列为叠加后的关节角度

## 关键帧残差系统

编辑逻辑说明：
- **Base 轨迹**: CSV 加载的原始轨迹，在左侧视口显示，不可修改
- **关键帧**: 用户编辑的特定时刻的机器人姿态（关节 + 基体）
- **残差**: 关键帧相对于 base 的偏移量
  - 关节残差 = `edited_joint - base_joint`
  - 基体残差 = `edited_base - base_base`（位置和四元数分别计算）
- **插值**: 关键帧之间的残差进行线性插值
  - 第一个关键帧之前：从 0 插值到第一个关键帧
  - 两个关键帧之间：线性插值
  - 最后一个关键帧之后：保持最后一个关键帧的值
- **最终输出**: 
  - `final_joint = base_joint + interpolated_joint_residual`
  - `final_base = base_base + interpolated_base_residual`（四元数会自动归一化）

这种设计的优势：
- 保留原始轨迹数据，可随时对比
- 仅存储修改的部分，节省空间
- 可以随时重置到 base 轨迹
- 支持平滑的过渡动画
- 双视口实时对比编辑效果

## 项目结构

```
robot-keyframe-editor/
├── index.html              # 主 HTML 文件（UI 布局）
├── package.json            # 项目配置和依赖
├── vite.config.js          # Vite 配置
├── .gitignore              # Git 忽略文件
├── src/
│   ├── main.js             # 主应用入口（场景管理、双视口渲染）
│   ├── urdfLoader.js       # URDF 文件加载器（支持从文件映射加载）
│   ├── trajectoryManager.js # 轨迹管理器（base + 关节/基体残差）
│   ├── jointController.js  # 关节控制器（UI + 自动更新）
│   ├── baseController.js   # 基体控制器（位置 + 四元数归一化）
│   └── timelineController.js # 时间轴控制器（播放/暂停、关键帧标记）
└── .github/
    └── copilot-instructions.md # AI 辅助开发说明
```

## 开发说明

### 核心模块

- **main.js**: 应用主类，负责场景初始化、双视口渲染和模块协调
- **urdfLoader.js**: 
  - 处理 URDF 文件夹加载和 mesh 解析
  - 支持 4 层路径匹配策略
  - `loadFromMap()` 方法用于创建第二个机器人实例
- **trajectoryManager.js**: 
  - 管理 base 轨迹、关键帧和残差插值
  - 支持关节和基体两种残差
  - 线性插值算法处理边界情况
- **jointController.js**: 关节 UI 控制、值更新、自动关键帧更新
- **baseController.js**: 基体控制（位置 + 四元数），自动归一化
- **timelineController.js**: 时间轴交互、播放/暂停、帧同步、关键帧标记

### 技术亮点

1. **双视口渲染**：
   - 使用 `setViewport` 和 `setScissor` 实现左右分屏
   - 一个渲染器渲染两个独立场景
   - 相机同步机制

2. **机器人实例管理**：
   - 左右视口各有独立的机器人模型
   - 通过 `loadFromMap()` 复用文件映射创建第二个实例
   - 避免 Three.js clone() 对复杂模型的不完整支持

3. **残差系统**：
   - 支持关节和基体两种残差
   - 线性插值处理关键帧之间的过渡
   - 自动更新机制（在关键帧上修改时）

4. **智能文件处理**：
   - CSV 加载时记录原始文件名
   - 导出时自动添加 `_modified` 后缀
   - 加载新 CSV 时清空关键帧状态

### 扩展功能建议

- [x] 支持播放/暂停动画
- [x] 双视口对比显示
- [x] 基体位置和姿态编辑
- [x] 自动关键帧更新
- [ ] 支持多种插值方式（样条、贝塞尔）
- [ ] 添加撤销/重做操作
- [ ] IK（逆运动学）支持
- [ ] 碰撞检测
- [ ] 关键帧曲线编辑器

## 常见问题

### Q: 左侧视口没有显示机器人？
A: 这可能是机器人实例创建延迟导致的。确保：
- URDF 文件加载成功（查看控制台）
- 稍等片刻让第二个实例异步加载完成
- 如果持续不显示，刷新页面重新加载

### Q: URDF 加载失败怎么办？
A: 确保文件夹包含完整的 URDF 文件和所有引用的 mesh 文件。工具支持 4 种路径匹配策略，查看控制台的详细日志了解哪些文件未找到。

### Q: 关键帧如何插值？
A: 使用线性插值：
- 第一个关键帧之前：从 0 插值到第一个关键帧
- 两个关键帧之间：线性插值
- 最后一个关键帧之后：保持最后一个关键帧的值

### Q: 如何重置到原始轨迹？
A: 点击右侧面板的"重置"按钮，可以将当前帧恢复到 base 值。要清除所有关键帧，重新加载 CSV 文件。

### Q: 基体四元数为什么会自动改变？
A: 每次修改四元数后会自动归一化（确保 x² + y² + z² + w² = 1），这是四元数的数学要求。

### Q: 两个视口的相机为什么会同步？
A: 为了方便对比，操作任一相机时会自动同步另一个。这样可以从相同视角查看两个轨迹的差异。

## 故障排除

### URDF 加载问题
- 确保上传的是完整的文件夹（包含所有引用的 mesh 文件）
- 检查控制台日志查看具体的文件匹配情况
- 支持的 mesh 格式：.stl, .dae, .obj 等

### 左侧视口空白
- 等待几秒让第二个机器人实例加载
- 刷新页面重试
- 检查控制台是否有错误信息

### 关节数量不匹配
- 确保 CSV 的列数 = 7（base）+ 关节数量
- 检查 URDF 中定义的可动关节数量

## License

MIT

